---
title: " 🚀 [Kafka] About Kafka Record"
description: "Kafka KRaft 소개글입니다."
date: "2024-10-28"
banner:
  src: "../../images/kafka/kafka.png"
  alt: "Kafka"
  caption:
categories:
  - "Kafka"
  - "ALL"
keywords:
  - "Pipeline"
  - "Kafka"
---
# 🚀 Apache Kafka Record

## 🔎 Overview

카프카의 데이터를 부르는 명칭인 Record에 대하여.

## Record

<img src="https://raw.githubusercontent.com/jms0522/jms0522.github.io/main/content/images/kafka/record.png" alt="Record" width="600" />

## 구조

레코드는 타임스탬프, 헤더 , 메시지 키, 오프셋으로 구성되어 있습니다.

프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정되어 저장이 됩니다.

한 번 저장된 레코드는 임의로 삭제 할 수 없고 오직 로그의 리텐션 기간 및 용량을 설정해 놓은 값에 따라서 삭제 됩니다.

### timestamp

시간을 저장하는 용도로 사용합니다.

따로 설정을 하지 않으면 기본 값인 프로듀서의 생성 시간(CreateTime)이 들어가게 됩니다.

혹은 브로커에 적재된 시간(LogAppendTime)으로 설정이 가능합니다.

해당 옵션은 토픽 단위로 설정이 가능하며 log.message.timestamp.type 의 설정을 통해 가능합니다.

이러한 옵션을 통해 메시지의 생성 시간과 적재 시간의 차이를 계산하여 네트워크 전송 지연 시간을 체크할 수 있을 것 같습니다.

### offset

프로듀서가 전송한 레코드가 브로커에 적재 될 시점에 오프셋이 지정됩니다.

0부터 시작하여 1씩 증가하게 되고 컨슈머는 오프셋을 기준으로 읽은 데이터와 처리해야 할 데이터를 구분합니다. (Commit)

각 메시지는 파티션 별로 고유한 오프셋을 가지므로 컨슈머에서 중복 처리를 방지하기 위한 목적으로도 사용합니다.

### Header

key/value 데이터를 추가할 수 있습니다.

### Message key

메시지 값의 분류하기 위한 용도로 사용되며 이를 파티셔닝이라고 부릅니다.

간단한 설명으로 메시지 키를 통해 어떤 파티션에 들어갈건지 지정할 수 있다고 생각하시면 됩니다.

메시지 키를 지정하지 않으면 (null) RR 방식으로 파티션에 분배해 저장합니다.

null이 아닌 메시지 키는 특정 파티션에 맵핑되어 전달됩니다.

### Value

메시지 값은 실질적으로 처리 할 데이터가 담기는 공간입니다.

메시지의 포맷 값은 사용자애 의해 지정이 되는데, 다양한 형태가 가능합니다.

필요에 따라 사용자 지정 포맷으로 직렬화/역직렬화 클래스를 만들어 사용도 가능합니다.

브로커에 저장된 레코드의 메시지 값은 어떤 포맷으로 직렬화 되어 저장되는지 알 수 없기에 컨슈머는 역직렬화 포맷을 알아야 합니다.

여기서 잠깐 ☝️

직렬화와 역직렬화는 데이터 무결성을 유지하고 전송 효율을 높여줍니다.

정확히 무엇인지 한 번 봐보죠!

#### 직렬화 Serialization ?

프로듀서와 컨슈머가 전송을 하고 수신을 할 때 데이터를 각각 직렬화 하고 역직렬화 하는데 이것은 kafka가 메시지를 바이트 배열 형식으로 처리하기 때문입니다.

직렬화는 객체를 바이트 배열로 바꾸는거라 생각하면 될 것 같습니다.

#### 역직렬화 Deserialization ?

바이트 배열을 원래 형식으로 복원하는 과정입니다.

바이트 배열을 객체로 복원한다고 생각하시면 됩니다.

## 마무리

오늘은 record에 대해서 알아보았는데요.

뭐든 하나하나 쉽게 가는 게 없는 거 같네요 😅




